Introduction

This package provides a simple framework for using Erlang Actors.

Installation

This package is built using Maven (http://maven.apache.org/).  Once you have
installed Maven, simply run "mvn clean install", and it will build the jar.

Usage

Each actor runs in a separate thread and must extend com.nps.concurrent.Actor.

Each actor must implement process() to handle messages.  To retrieve
further messages within process(), call one of the versions of next().  To
send a message to an actor, invoke recv() on that actor.  Ideally, all
actors should have no public functions beyond what is required to
initialize them before the messages start flying, because this eliminates
the need for locks, but this is probably not realistic in a complex system.

Each actor must be configured with an execution model:

   * com.nps.concurrent.PersistentThreadActorExecution
   * com.nps.concurrent.ThreadPoolActorExecution
   * com.nps.concurrent.JITThreadActorExecution

Ideally, you should instantiate a separate execution instance for each
actor.  However, for convenience, you can pass the same execution instance
to multiple actors, and it will be duplicated for you.

Each ThreadPoolActorExecution requires that you provide an ActorThreadPool
in which the actor will run.  You can have multiple ActorThreadPools, but
each Actor runs in a single, specific pool.  Actors that are constantly
busy should use PersistentThreadActorExecution to avoid monopolizing the
threads in a pool.  The size of each ActorThreadPool should be tuned to
avoid congestion.  If there are too few threads, actors may have to wait a
long time before they get a time slice.  To ensure that all messages are
eventually processed, actors must never block waiting for a message.
Instead, they should sleep after storing internal state describing what to
do when the expected message eventually arrives.

The unit tests suggest that PersistentThreadActorExecution is only
fractionally faster than ThreadPoolActorExecution.  The latter has
additional latency since it can cause actors to wait for an available
thread.  JITThreadActor is significantly slower because thread creation is
expensive, but if you're starved for memory, i.e., you can't use a
persistent thread, and you don't want to wait in a thread pool queue, then
this might be an option, especially if it doesn't receive messages very
often.

Change Log

1.1  John Lindal  2009-09-17

   * Refactored SimpleActor into Actor and PersistentThreadActorExecution.
     Instead of using inheritance, an actor must be passed an execution model.
   * Actor.process() no longer returns boolean.  Call die() instead.
   * Created ThreadPoolActorExecution for actors that do not require
     dedicated threads.
   * Created JITPoolActorExecution for actors that should create a thread
     on demand.
   * Fixed appropriate classes to be public.
   * Moved MessageFilter class out of ActorBase.
   * Added get/setMessageFilter() to ActorExecution.
