Introduction

This package provides a simple framework for using Erlang Actors.

Installation

This package is built using Maven (http://maven.apache.org/).  Once you have
installed Maven, simply run "mvn clean install", and it will build the jar.

Usage

Each actor runs in a separate thread and must extend com.nps.concurrent.Actor.

Each actor must implement process() to handle messages.  To retrieve
further messages within process(), call one of the versions of next().  To
send a message to an actor, invoke recv() on that actor.  Ideally, all
actors should have no public functions beyond what is required to
initialize them before the messages start flying, because this eliminates
the need for locks, but this is probably not realistic in a complex system.

Each actor must be configured with an agent:

   * com.nps.concurrent.PersistentThreadAgent
   * com.nps.concurrent.ThreadPoolAgent
   * com.nps.concurrent.JITThreadAgent

Ideally, you should instantiate a separate agent instance for each actor.
However, for convenience, you can pass the same agent instance to multiple
actors, and it will be duplicated for you.  Note that each actor is
expected to install its own MessageFilter, so this is not copied.

Each ThreadPoolAgent requires that you provide an ActorThreadPool in which
the actor will run.  You can have multiple ActorThreadPools, but each Actor
runs in a single, specific pool.  Actors that are constantly busy should
use PersistentThreadAgent to avoid monopolizing the threads in a pool.  The
size of each ActorThreadPool should be tuned to avoid congestion.  If there
are too few threads, actors may have to wait a long time before they get a
time slice.  To ensure that all messages are eventually processed, actors
must never block waiting for a message.  Instead, they should sleep after
storing internal state describing what to do when the expected message
eventually arrives.

The unit tests suggest that ThreadPoolAgent can be faster than
PersistentThreadAgent.  The former may have additional latency since it can
cause actors to wait for an available thread, but having fewer threads
executing simultaneously can be faster.  JITThreadActor is significantly
slower because thread creation is expensive, but if you're starved for
memory, i.e., you can't use a persistent thread, and you don't want to wait
in a thread pool queue, then this might be an option, especially if it
doesn't receive messages very often.

Change Log

1.1  John Lindal  2009-09-17

   * Refactored SimpleActor into Actor and PersistentThreadAgent.
     Instead of using inheritance, an actor must be passed an agent.
   * Actor.process() no longer returns boolean.  Call die() instead.
   * Created ThreadPoolAgent for actors that do not require dedicated threads.
   * Created JITPoolAgent for actors that should create a thread on demand.
   * Fixed appropriate classes to be public.
   * Moved MessageFilter class out of ActorBase.
   * Added get/setMessageFilter() to Agent.
